#version 450
#extension GL_EXT_debug_printf : enable

layout(local_size_x = 256) in;

struct TetraElement {
    uint vertices[4];
    float temperature;
    float coolingRate;
    float thermalConductivity;
};

layout(binding = 0) buffer TetraBuffer {
    TetraElement elements[];
} tetraBuffer;

layout(binding = 1) buffer TemperatureWriteBuffer { // Temperature write buffer
    float temperatures[];
} temperatureWriteBuffer;

layout(binding = 2) buffer TemperatureReadBuffer {  // Temperature read buffer
    float temperatures[];
} temperatureReadBuffer;

layout(binding = 4) buffer CenterBuffer {
    vec4 centers[];
} centerBuffer;

layout(binding = 5) uniform TimeBuffer {
    float deltaTime;
    float totalTime;
} timeBuffer;

void main() {
    uint tetraID = gl_GlobalInvocationID.x;
    if (tetraID >= tetraBuffer.elements.length()) return;

    // Get the current tetrahedron
    TetraElement tetra = tetraBuffer.elements[tetraID];
    float temperature = temperatureReadBuffer.temperatures[tetraID];
    float coolingRate = tetra.coolingRate;
    float thermalConductivity = tetra.thermalConductivity;

    // Linear cooling
    temperature -= coolingRate * timeBuffer.deltaTime;

    // Heat diffusion between neighbors
    vec3 center = centerBuffer.centers[tetraID].xyz;
    float heatTransfer = 0.0;
    int neighborCount = 0;

    for (uint t = 0; t < centerBuffer.centers.length(); t++) {
        if (t == tetraID) continue; // Skip self

        vec3 neighborCenter = centerBuffer.centers[t].xyz;
        float dist = distance(center, neighborCenter);

        // Adjust interaction radius for a 0.2 x 0.2 x 0.2 model
        if (dist < 0.05) { // Smaller radius for smaller model
            float tempDiff = temperatureReadBuffer.temperatures[t] - temperature;
            float absTempDiff = abs(tempDiff);
            if (temperatureReadBuffer.temperatures[t] > temperature) {
                heatTransfer += absTempDiff * thermalConductivity * timeBuffer.deltaTime;
            } else {
                heatTransfer -= absTempDiff * thermalConductivity * timeBuffer.deltaTime;
            }
            neighborCount++;
        }
    }

    // Normalize heat transfer by the number of neighbors
    if (neighborCount > 0) {
        heatTransfer /= neighborCount;
    }

    // Apply heat transfer
    temperature += heatTransfer;

    // Clamp temperature to avoid negative values
    temperature = max(temperature, 0.0);

    // Write back the updated temperature
    temperatureWriteBuffer.temperatures[tetraID] = temperature;
    //debugPrintfEXT("Tetra ID: %i, Updated Temp: %f\n", tetraID, temperature); 
}